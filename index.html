<!doctype html>
<html lang="en-US">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport"     content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="default-style"  content="text/html; charset=UTF-8" />

  <meta name="author"       content="Viola T.Whiting" />
  <meta name="description"  content="Shitpost to call BS and disprove OOD and Functional." />
  <meta name="keywords"     content="coding,comparison,experiment,prove,OOP,confusion,learning,perspective" />


  <link rel="stylesheet" href="newdomainwho.css" />


<!--  Quicksand  -->
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400&display=swap" rel="stylesheet">

<!--  Montaga  -->
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Montaga&display=swap" rel="stylesheet">

<!--  Source Code Pro  -->
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300;600&display=swap" rel="stylesheet">


  <title>{ }Calculator Challenge: Demonstrate Your Programming Paradigm Is Even Real</title>


</head>
<body>

  <h1>Demonstrate Your Programming Paradigm Is Even Real</h1>

<main>

  <h2>Calculator Challenge</h2>

  <br>

<section  id="opening_narrative">

  <p  class="disclaimer">The following is a dramatization of actual accounts.</p>

  <br>

  <aside>Angry.js</aside>

  <p>The instructor, wearing a hoodie too young for that generation, attests to an intuitive programming paradigm by mapping real-world objects.  A demonstration is given using squares, circles and triangles. The mic is dropped, leaving questions on the floor.  The assignment is to write a basic text-based "conversational" server.  Do you know where to fit the squares, circles and triangles?</p>

  <p>Never mind.  College already has my money; it provided fool's errands.</p>

  <p>Years later these squares, circles and triangles have yet to be a nuisance.  It is all about best practices.  Clear, logical, categorized rationalizations.  Then, word on the street is that there is a new paradigm revolution on the rise.  In a mouse&ndash;infested lair under the city sidewalk, suitable for some teen-aged turtles, an obvious Mr. Robot imitator tells of purity using esoteric patterns.  Programs so pure there is no state!</p>

  <p>This same level of ambivalence is what one can expect from conservative news and religion.  How can this be the same STEM field as the women who got the United States into space and beyond Earth??  Yet, one does not have to scroll too deep into the answers of Stack Overflow before it becomes obvious how an accidental pregnancy with one's own cousin is even a thing.  Let's talk about the Emperor's clothes.  Convince and create practitioners of your paradigm.</p>

</section>

  <br>

<section  id="requirements">

  <h3>The Challenge</h3>

  <aside><q>Put your code where your fucking mouth is.</q></aside>

  <p>Using a sole paradigm of either true OOD <small>(Java)</small> or pure functions <small>(Haskell)</small>, write a complete program <small>(include source code)</small> satisfying the following:</p>

  <ol>
    <li><p>Unbreakable, self-contained executable for use within a terminal.  No additional installation of any kind required to run your program.  Standard library and system calls only!  <small>(Because those are the boundaries of a language's runtime.)</small></p>
      <ul>
        <li>
          <small>Compile on at least GNU/Linux.</small>
        </li>
        <li>
          <small>Signal interrupts will be excused.</small>
        </li>
        <li>
          <small>Copyright infringement will be ignored.</small>
        </li>
      </ul>
    </li>

    <li><p>Accept typed input from the user to acquire a mathematical equation for the program to calculate upon the user pressing <kbd>ENTER</kbd>.  Must always compute a numerical answer to the user's equation and be mathematically correct<small><sup><strong>*</strong></sup></small>, or a <dfn>DNE</dfn> <small>(Does Not Exist)</small> or <dfn>NaN</dfn> <small>(Not a Number)</small> indicator for a 0-divisor incidence.</p>
  <p>  <small><sup><strong>*</strong></sup> Not concerned about integer overflow and float round-offs.  Just do not break otherwise!</small></p></li>

    <li><p>On a new line each, repeat accepting inputted equations from the user and computing them upon the user pressing <kbd>ENTER</kbd> until the user hits <kbd>ESC</kbd> <em>at any point</em> to terminate program.</p></li>

    <li><p>Capabilities must include many uses (at least four) of each: nested parentheses, divisors <wbr>( <kbd>/</kbd> )<wbr>, additions <wbr>( <kbd>+</kbd> )<wbr>, and decimal numbers.</p>
      <ul>
        <li>
          <small>Not necessary to handle positive/negative notation from the user's inputs.</small>
        </li>
      </ul>
    </li>

    <li><p>Limit user's inputs to forming only equations the program is capable of calculating.</p>
      <ul>
        <li>
          <small>Handling of excess opening/closing parentheses or empty parentheses from the user is your choice, not relevant.</small>
        </li>
        <li>
          <small>Also not concerned about use of <kbd>BACKSPACE</kbd> from the user.</small>
        </li>
      </ul>
    </li>

    <li><p>Program will always be able to continue functioning, no dead-ends.  Only ignore a pre-mature <kbd>ENTER</kbd> press (equation calculation) if still requiring/waiting for the user's equation to be properly inputted.  For example: still needing a numerical input to follow an "operator" input <wbr>( <kbd>/</kbd> <wbr>or<wbr> <kbd>+</kbd> ).</p></li>

    <li><p><small>(Skipped for expedition.)</small>  &nbsp;&nbsp;
<small><s>Parse from the command line/shell.  Validate the inputted equation and provide the correct mathematical answer at startup.  Then continue, just the same as done with an interactive user, as described above.  In addition to numerical or <dfn>DNE</dfn> answers, this step is allowed to indicate an invalid equation was provided, then continue.</s></small></p>
      <ul>
        <li>
          <small><s>Ignore <kbd>spaces</kbd> from the command line/shell.</s></small>
        </li>
      </ul>
    </li>
  </ol>


</section>

  <br>

<section  id="critique">

  <h3>Observations</h3>

  <p>The OOD and functional submissions will be contrasted to a structural benchmark of the challenge with best practices written in the C Programming Language, which is specifically <em>not</em> an object-oriented language, and specifically <em>not</em> a functional language.  It is reasonable to expect that the architectures of all the implementations will be contorted to that of its paradigm; <em>not be identical logically</em>, despite language features</p>

  <br>

  <h4>OOD vs Structured Best Practices</h4>

  <ul>
    <li>
      <p><em>Is the same logic able to be implemented in C?  </em></p>
    <p><small>  A language feature is not a paradigm.  A technique or "pattern" is not a paradigm.</small></p>
    </li>

    <li>
      <p><em>Is everything oriented as an object?  </em></p>
      <p><small>  If everything isn't an instantiated object and <em>relevantly so</em>, it would just be equivalent to refer to the structured benchmark as array-oriented or pointer-oriented.</small></p>
    </li>

    <li>
      <p><em>Can everything be re-used?  </em></p>
      <p><small>  If an object cannot be instantiated more than once within the same process (without being threaded), then what's the difference?</small></p>
    </li>

    <li>
      <p><em>Is everything mapped to real-world objects?  </em></p>
    <p><small>  Every procedure in programming is a verb.  How are nouns used instead?</small></p>
    </li>

    <li>
      <p><em>Is anything wrapped in a class and instantiated that is just the same logic as a structured implementation?  </em></p>
      <p><small>  That is just redundant.</small></p>
    </li>

    <li>
      <p><em>Is it more intuitive to write than a structured implementation?</em></p>
    </li>

    <li>
      <p><em>Is it more modular?  More encapsulated?  More abstracted?</em></p>
    </li>

    <li>
      <p><em>Is there more inheritance?  More polymorphism?</em></p>
    </li>

    <li>
      <p><em>Is it best to provide comments?</em></p>
    </li>

    <li>
      <p><em>Is it faster to add new features?</em></p>
    </li>
  </ul>

  <br>

  <h4>Functional vs Structured Best Practices</h4>

  <ul>
    <li>
      <p><em>Is the same logic able to be implemented in C?  </em></p>
      <p><small>  A language feature is not a paradigm.  A technique or "pattern" is not a paradigm.</small></p>
    </li>

    <li>
      <p><em>Is there any state at all?</em></p>
      <p><small>  It is too easy just to write functions without side-effects.</small></p>
    </li>

    <li>
      <p><em>Is there a re-assignment anywhere in the program?  </em></p>
      <p><small>  That is mutable data.  (I only know about the term "immutable data" from functional programmers.)</small></p>
    </li>

    <li>
      <p><em>Is it best to provide comments?</em></p>
    </li>

    <li>
      <p><em>Bug found?  </em></p>
      <p><small>  Debugging is the most costly endeavor and it is far less likely to be necessary if functions cannot have side-effects, and programs do not have state.</small></p></li>
  </ul>

</section>

  <br>

<section>

  <h3>More Kettlebells & Essential Oils!</h3>

  <br>

  <ul>
    <li><p>Serverless: The New Server Is Just Like The Old Server!</p></li>
    <li><p>RESTful API For You!  And You!  RESTful APIs For Everybody!</p></li>
    <li><p>New <em>Dictionary</em> Entry For <em>Associative Array</em>!</p></li>
    <li><p>Favor Quantum Mechanics: At Least It's Comprehensive Ambiguity&mdash;Not Ambivalence!</p></li>
    <li><p>Lexiconal Bastardization: If You're Not Lingo-huckstering, Are You Even English, Yo!</p></li>
  </ul>

</section>

  <br>

</main>

  <br>

<footer>
  <object  name="footer"  data="footer.html"  type="text/html"></object>
</footer>


</body>
</html>
